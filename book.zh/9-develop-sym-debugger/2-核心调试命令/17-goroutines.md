go语言既然是面向协程的，我们的调试器就应该提供协程级的调试控制能力，比如切换到g1去执行并调试，或者切换到g2去执行并调试。这个功能在多线程调试中是很常见的，比如eclipse里面调试java多线程程序时，我们可以暂停其他线程只调试一个线程，或者允许某个线程跑起来并对其进行调试。gdb还提供了对fork后线程自动跟踪的能力（--follow-forked，忘记具体那个选项了）。

总而言之，调试go程序，如果只能实现多线程调试，其实还是比较鸡肋的，我们都清楚GPM调度模型中，一个M可能执行很多个协程，切换来切换去的，假如我们只能跟踪到线程级别，那我们其实还是比较难判断当前是跟踪的哪个协程的。

当然了，不是说完全不能调试，毕竟在单个线程上添加的断点，在这个线程执行g上的逻辑期间我们还是可以正常调试的，只是说，如果我们想切换到某个协程去运行时，则可能会比较困难，比如我只想让协程g2在恢复调度时立即停下来，我也不关心它停在哪里，这个时候goroutine goid就非常方便了。

要实现goroutine级别的控制能力，需要对go源码g理解比较透彻，至少要能区分不同的g（goid是如何存储的），g恢复执行后的下一条指令（g的协程上下文信息），blabla……

我们要支持这个功能。



TODO 任务优先级：高