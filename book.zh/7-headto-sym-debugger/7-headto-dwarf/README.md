## 挺近DWARF

前面介绍go标准库debug/dwarf时，我们展示了几个读取DWARF中源文件、函数名、函数参数信息的示例，但是我们没有讨论 ：

1. 这些DWARF调试信息具体是如何生成的？
   我们知道是编译器、链接器生成的，但是具体的生成过程是怎样的，编译器和链接器在这个过程中分别做了哪些工作？
2. 生成DWARF调试信息时具体是利用了DWARF的哪些描述能力？
   针对不同的类型、变量、常量、函数（包括参数、返回值及局部变量）、调用栈、行号表，Go工具链如何用DWARF来描述的？要先理解这部分才能反过来实现正确的读取。
   包括后续调试器实现时，我们可能要经常写一些测试用的小程序片段，检查Go编译工具链生成的DWARF调试信息，理解它然后再尝试去读取它、将它和源码关联起来。
3. go标准库对DWARF数据的读写足够完备吗？
   在前面准备DWARF数据读取的示例时，我们发现并不是DWARF v4里面所有的关键描述信息(.debug_ sections)都有被读取，比如调用栈.debug_frame就没有被读取。
4. 除了go标准库以外，还有没有其他维护更好的Go DWARF开源库？
   比如go-delve/delve这个调试器，几乎是随着go语言发展而同步发展的，这期间go团队对DWARF的支持有限，那delve开发者是解决DWARF数据读写问题的。
5. 实现一个基于DWARF的符号级调试器，有哪些库可以使用帮我们解决DWARF数据的读写问题？
   不同语言的不同程序构造，其DWARF描述也不同，如果从0开始实现DWARF数据读写逻辑，工作量很大。我们要对比下go标准库、delve等项目中的实现来选择合适的库。

这些是咱们理解了调试原理之后，进一步去工程化时必须要思考的一个问题。本节我们就来继续钻研下。
