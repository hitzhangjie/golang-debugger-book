## æ‰©å±•é˜…è¯»ï¼šå¦‚ä½•è·Ÿè¸ªæ–°åˆ›å»ºçš„çº¿ç¨‹

### å®ç°ç›®æ ‡

å‰é¢æ¼”ç¤ºè°ƒè¯•å™¨æ“ä½œæ—¶ï¼Œä¸ºäº†ç®€åŒ–å¤šçº¿ç¨‹è°ƒè¯•çš„æŒ‘æˆ˜ï¼Œæœ‰äº›æµ‹è¯•åœºæ™¯æˆ‘ä»¬ä½¿ç”¨äº†å•çº¿ç¨‹ç¨‹åºæ¥è¿›è¡Œæ¼”ç¤ºã€‚ä½†æ˜¯çœŸå®åœºæ™¯ä¸‹ï¼Œæˆ‘ä»¬çš„ç¨‹åºå¾€å¾€æ˜¯å¤šçº¿ç¨‹ç¨‹åºã€‚

æˆ‘ä»¬çš„è°ƒè¯•å™¨å¿…é¡»å…·å¤‡å¤šçº¿ç¨‹è°ƒè¯•çš„èƒ½åŠ›ï¼Œè¿™é‡Œæœ‰å‡ ç±»åœºæ™¯éœ€è¦ç‰¹åˆ«å¼ºè°ƒä¸‹ï¼š

- çˆ¶å­è¿›ç¨‹ï¼Œåœ¨è°ƒè¯•å™¨å®ç°è¿‡ç¨‹ä¸­ï¼Œè·Ÿè¸ªçˆ¶å­è¿›ç¨‹å’Œè·Ÿè¸ªè¿›ç¨‹å†…çš„çº¿ç¨‹ï¼Œå®ç°æŠ€æœ¯ä¸Šå·®åˆ«ä¸å¤§ã€‚
  å› ä¸ºè¿™æ˜¯ä¸€æ¬¾é¢å‘goè°ƒè¯•å™¨çš„ä¹¦ç±ï¼Œæ‰€ä»¥æˆ‘ä»¬åªä¸“æ³¨å¤šçº¿ç¨‹è°ƒè¯•ã€‚å¤šè¿›ç¨‹è°ƒè¯•æˆ‘ä»¬ä¼šç‚¹ä¸€ä¸‹ï¼Œä½†æ˜¯ä¸ä¼šä¸“é—¨å¼€ä¸€èŠ‚æ¥ä»‹ç»ã€‚
- çº¿ç¨‹çš„åˆ›å»ºæ—¶æœºé—®é¢˜ï¼Œå¯èƒ½æ˜¯åœ¨æˆ‘ä»¬attachä¹‹å‰åˆ›å»ºå‡ºæ¥çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯æˆ‘ä»¬attachä¹‹åçº¿ç¨‹é€šè¿‡cloneåˆæ–°åˆ›å»ºå‡ºæ¥çš„ã€‚
  - å¯¹äºè¿›ç¨‹å·²ç»åˆ›å»ºçš„çº¿ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦å…·å¤‡æšä¸¾å¹¶ä¸”å‘èµ·è·Ÿè¸ªã€åˆ‡æ¢ä¸åŒçº¿ç¨‹è·Ÿè¸ªçš„èƒ½åŠ›ï¼›
  - å¯¹äºè¿›ç¨‹è°ƒè¯•æœŸé—´æ–°åˆ›å»ºçš„çº¿ç¨‹ï¼Œæˆ‘ä»¬éœ€è¦å…·å¤‡å³æ—¶æ„ŸçŸ¥çº¿ç¨‹åˆ›å»ºï¼Œå¹¶æç¤ºç”¨æˆ·é€‰æ‹©è·Ÿè¸ªå“ªä¸ªçº¿ç¨‹çš„èƒ½åŠ›ï¼Œæ–¹ä¾¿ç”¨æˆ·å¯¹æ„Ÿå…´è¶£çš„äº‹ä»¶è¿›è¡Œè§‚å¯Ÿã€‚

æœ¬èŠ‚æˆ‘ä»¬å°±å…ˆçœ‹ä¸‹å¦‚ä½•è·Ÿè¸ªæ–°åˆ›å»ºçš„çº¿ç¨‹ï¼Œå¹¶è·å–æ–°çº¿ç¨‹çš„tidå¹¶å‘èµ·è·Ÿè¸ªï¼Œä¸‹ä¸€èŠ‚æˆ‘ä»¬çœ‹ä¸‹å¦‚ä½•æšä¸¾å·²ç»åˆ›å»ºçš„çº¿ç¨‹å¹¶é€‰æ‹©æ€§è·Ÿè¸ªæŒ‡å®šçº¿ç¨‹ã€‚

### åŸºç¡€çŸ¥è¯†

newosprocåˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹ï¼ˆnewprocåˆ›å»ºä¸€ä¸ªæ–°çš„goroutine)ï¼Œæ˜¯é€šè¿‡ `clone` ç³»ç»Ÿè°ƒç”¨æ¥å®Œæˆçš„ï¼Œ

```go
// cloneåˆ›å»ºçº¿ç¨‹æ—¶çš„å…‹éš†å‚æ•°
const (
	cloneFlags = _CLONE_VM | /* share memory */
		_CLONE_FS | /* share cwd, etc */
		_CLONE_FILES | /* share fd table */
		_CLONE_SIGHAND | /* share sig handler table */
		_CLONE_SYSVSEM | /* share SysV semaphore undo lists (see issue #20763) */
		_CLONE_THREAD /* revisit - okay for now */
)

// åˆ›å»ºä¸€ä¸ªæ–°çš„çº¿ç¨‹
func newosproc(mp *m) {
	stk := unsafe.Pointer(mp.g0.stack.hi)
	/*
	 * note: strace gets confused if we use CLONE_PTRACE here.
	 */
	if false {
		print("newosproc stk=", stk, " m=", mp, " g=", mp.g0, " clone=", abi.FuncPCABI0(clone), " id=", mp.id, " ostk=", &mp, "\n")
	}

	// Disable signals during clone, so that the new thread starts
	// with signals disabled. It will enable them in minit.
	var oset sigset
	sigprocmask(_SIG_SETMASK, &sigset_all, &oset)
	ret := clone(cloneFlags, stk, unsafe.Pointer(mp), unsafe.Pointer(mp.g0), unsafe.Pointer(abi.FuncPCABI0(mstart)))
	sigprocmask(_SIG_SETMASK, &oset, nil)

	if ret < 0 {
		print("runtime: failed to create new OS thread (have ", mcount(), " already; errno=", -ret, ")\n")
		if ret == -_EAGAIN {
			println("runtime: may need to increase max user processes (ulimit -u)")
		}
		throw("newosproc")
	}
}

//go:noescape
func clone(flags int32, stk, mp, gp, fn unsafe.Pointer) int32
```

ä¸Šè¿°cloneå‡½æ•°å®šä¹‰çš„å®ç°ï¼Œåœ¨amd64æ¶æ„ä¸­æ˜¯è¿™æ ·å®ç°çš„ï¼Œcloneå‡½æ•°å®ç° see go/src/runtime/sys_linux_amd64.s:

```go
 // int32 clone(int32 flags, void *stk, M *mp, G *gp, void (*fn)(void));
TEXT runtimeÂ·clone(SB),NOSPLIT,$0
	MOVL	flags+0(FP), DI 	// å‡†å¤‡ç³»ç»Ÿè°ƒç”¨å‚æ•°
	MOVQ	stk+8(FP), SI
	...

	// Copy mp, gp, fn off parent stack for use by child.
	// Careful: Linux system call clobbers CX and R11.
	MOVQ	mp+16(FP), R13
	MOVQ	gp+24(FP), R9
	MOVQ	fn+32(FP), R12
	...

	MOVL	$SYS_clone, AX 		// cloneç³»ç»Ÿè°ƒç”¨å·
	syscall				// æ‰§è¡Œç³»ç»Ÿè°ƒç”¨

	// In parent, return.
	CMPQ	AX, $0
	JEQ	3(PC)
	MOVL	AX, ret+40(FP)		// çˆ¶è¿›ç¨‹ï¼Œè¿”å›cloneå‡ºçš„æ–°çº¿ç¨‹çš„tid
	RET

	// In child, on new stack.
	MOVQ	SI, SP

	// If g or m are nil, skip Go-related setup.
	CMPQ	R13, $0    // m
	JEQ	nog2
	CMPQ	R9, $0    // g
	JEQ	nog2

	// Initialize m->procid to Linux tid
	MOVL	$SYS_gettid, AX
	SYSCALL
	MOVQ	AX, m_procid(R13)

	// In child, set up new stack
	get_tls(CX)
	MOVQ	R13, g_m(R9)
	MOVQ	R9, g(CX)
	MOVQ	R9, R14 // set g register
	CALL	runtimeÂ·stackcheck(SB)

nog2:
	// Call fn. This is the PC of an ABI0 function.
	CALL	R12			// æ–°çº¿ç¨‹ï¼Œåˆå§‹åŒ–ç›¸å…³çš„gmpè°ƒåº¦ï¼Œå¼€å§‹æ‰§è¡Œçº¿ç¨‹å‡½æ•°mstartï¼Œ
					// cloneå‚æ•°ä¸­æœ‰ä¸ª abi.FuncPCABI0(mstart)
	...
```

ç”±æ­¤å¯çŸ¥ï¼Œå…¶å®åªè¦traceeæ‰§è¡Œç³»ç»Ÿè°ƒç”¨cloneæ—¶ï¼Œå†…æ ¸ç»™æˆ‘ä»¬ä¸€ä¸ªé€šçŸ¥å°±å¯ä»¥äº†ï¼Œæ¯”å¦‚é€šè¿‡ `ptrace(PTRACE_SYSCALL, pid, ...)` ï¼Œè¿™æ ·traceeæ‰§è¡Œç³»ç»Ÿè°ƒç”¨cloneæ—¶ï¼Œåœ¨enter syscall cloneã€exit syscall cloneçš„ä½ç½®ä¼šåœä¸‹æ¥ï¼Œæ–¹ä¾¿æˆ‘ä»¬åšç‚¹è°ƒè¯•æ–¹é¢çš„å·¥ä½œï¼Œæˆ‘ä»¬å°±å¯ä»¥è¯»å–æ­¤æ—¶RAXå¯„å­˜å™¨çš„å€¼æ¥åˆ¤æ–­å½“å‰ç³»ç»Ÿè°ƒç”¨å·æ˜¯ä¸æ˜¯ `__NR_clone` ï¼Œå¦‚æœæ˜¯ï¼Œé‚£è¯´æ˜æ‰§è¡Œäº†ç³»ç»Ÿè°ƒç”¨cloneï¼Œæˆ‘ä»¬å°±å¯ä»¥å€Ÿæ­¤åˆ¤æ–­åˆ›å»ºäº†ä¸€ä¸ªæ–°çš„çº¿ç¨‹ã€‚åŒæ ·çš„å¯ä»¥åœ¨exit syscallçš„æ—¶å€™ç”¨ç±»ä¼¼çš„åŠæ³•å»è·å–æ–°çº¿ç¨‹çš„tidä¿¡æ¯ã€‚

é€šè¿‡è¿™ä¸ªåŠæ³•å¯ä»¥æ„ŸçŸ¥åˆ°traceeåˆ›å»ºäº†æ–°çº¿ç¨‹ï¼Œè¿™æ˜¯ä¸€ä¸ªåŠæ³•ï¼Œä½†æ˜¯è¿™ä¸ªåŠæ³• `ptrace(PTRACE_SYSCALL, pid, ...)` è¿‡äºé€šç”¨äº†ï¼Œä½ è¿˜è¦æ‡‚ç‚¹ABIè°ƒç”¨æƒ¯ä¾‹ï¼ˆæ¯”å¦‚å¯„å­˜å™¨åˆ†é…æ¥ä¼ æ¥ç³»ç»Ÿè°ƒç”¨å·ã€è¿”å›å€¼ä¿¡æ¯ï¼‰ï¼Œä½¿ç”¨èµ·æ¥å°±æ²¡æœ‰é‚£ä¹ˆæ–¹ä¾¿ã€‚

è¿˜æ˜¯æœ‰ä¸€ä¸ªåŠæ³•ï¼Œå°±æ˜¯åœ¨æ‰§è¡Œ `ptrace(PTRACE_ATTACH, pid, ...)` çš„æ—¶å€™ä¼ é€’é€‰é¡¹ `PTRACE_O_TRACECLONE` ï¼Œè¿™ä¸ªæ“ä½œæ˜¯ä¸“é—¨ä¸ºè·Ÿè¸ªcloneç³»ç»Ÿè°ƒç”¨è€Œè®¾ç½®çš„ï¼Œè€Œä¸”äº‹åå¯ä»¥é€šè¿‡

1ã€tracerï¼šrun `ptrace(PTRACE_ATTACH, pid, NULL, PTRACE_O_TRACECLONE)`
   è¯¥æ“ä½œå°†ä½¿å¾—traceeæ‰§è¡Œcloneç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå†…æ ¸ä¼šç»™tracerå‘é€ä¸€ä¸ªSIGTRAPä¿¡å·ï¼Œé€šçŸ¥æœ‰cloneç³»ç»Ÿè°ƒç”¨å‘ç”Ÿï¼Œæ–°çº¿ç¨‹æˆ–è€…æ–°è¿›ç¨‹è¢«åˆ›å»ºå‡ºæ¥äº†

2ã€tracerï¼šéœ€è¦ä¸»åŠ¨å»æ„ŸçŸ¥è¿™ä¸ªäº‹ä»¶çš„å‘ç”Ÿï¼Œæœ‰ä¸¤ä¸ªåŠæ³•ï¼š
    - é€šè¿‡ä¿¡å·å¤„ç†å‡½æ•°å»æ„ŸçŸ¥è¿™ä¸ªä¿¡å·çš„å‘ç”Ÿï¼›
    - é€šè¿‡waitpid()å»æ„ŸçŸ¥åˆ°traceeçš„è¿è¡ŒçŠ¶æ€å‘ç”Ÿäº†æ”¹å˜ï¼Œå¹¶é€šè¿‡waitpidè¿”å›çš„statusæ¥åˆ¤æ–­æ˜¯å¦æ˜¯PTRACE_EVENT_CLONEäº‹ä»¶
      see: `man 2 ptrace` ä¸­å…³äºé€‰é¡¹ PTRACE_O_TRACECLONE çš„è¯´æ˜ã€‚

3ã€tracerå¦‚æœç¡®å®šäº†æ˜¯cloneå¯¼è‡´çš„ä»¥åï¼Œå¯ä»¥è¿›ä¸€æ­¥é€šè¿‡ `newpid = ptrace(PTRACE_GETEVENTMSG, pid, ...)` æ‹¿åˆ°æ–°çº¿ç¨‹çš„pidä¿¡æ¯ã€‚

4ã€æ‹¿åˆ°çº¿ç¨‹pidä¹‹åå°±å¯ä»¥å»å¹²å…¶ä»–äº‹ï¼Œæ¯”å¦‚é»˜è®¤ä¼šè‡ªåŠ¨å°†æ–°çº¿ç¨‹çº³å…¥è·Ÿè¸ªï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©æ”¾è¡Œæ–°çº¿ç¨‹ï¼Œæˆ–è€…è§‚å¯Ÿã€æ§åˆ¶æ–°çº¿ç¨‹

> ps: å¯èƒ½ä¼šå¶å°”æ··ç”¨pidã€tidä¿¡æ¯ï¼Œå¯¹äºçº¿ç¨‹ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªcloneå‡ºæ¥çš„LWPï¼ˆè½»é‡çº§è¿›ç¨‹ï¼Œlight weight processï¼‰ï¼Œä½†æ˜¯å½“æˆ‘æƒ³æè¿°ä¸€ä¸ªçº¿ç¨‹çš„IDæ—¶ï¼Œåº”è¯¥ç”¨tidè¿™ä¸ªæœ¯è¯­ï¼Œè€Œä¸æ˜¯pidè¿™ä¸ªæœ¯è¯­ã€‚ä½†æ˜¯å› ä¸ºæŸäº›å‡½æ•°è°ƒç”¨å‚æ•°çš„åŸå› ï¼Œæˆ‘å¯èƒ½å¶å°”ä¼šå†™æˆä¸€æ ·çš„pidï¼Œæ¯”å¦‚attachä¸€ä¸ªçº¿ç¨‹çš„æ—¶å€™ï¼Œä¼ é€’çš„å‚æ•°åº”è¯¥æ˜¯tidï¼Œè€Œéè¿™ä¸ªçº¿ç¨‹çš„pidï¼Œå®ƒä¿©çš„å€¼ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ã€‚
>
> - è¿™ä¸ªçº¿ç¨‹æ‰€å±çš„è¿›ç¨‹pidï¼Œè¿™æ ·è·å– `getpid()`
> - è¿™ä¸ªçº¿ç¨‹çš„çº¿ç¨‹tidï¼ˆæˆ–è€…è¡¨è¿°æˆå¯¹åº”çš„lwpçš„pidï¼‰ï¼Œé€šè¿‡è¿™æ ·è·å– `syscall(SYS_gettid)`

ç¬¬äºŒç§æ–¹æ³•æ›´å®¹æ˜“ç†è§£å’Œç»´æŠ¤ï¼Œè®¾è®¡å®ç°æ—¶æˆ‘ä»¬å°†é‡‡ç”¨ç¬¬äºŒç§æ–¹æ³•ã€‚ä½†æ˜¯ç”±äºç¬¬ä¸€ç§æ–¹æ³•ä¹Ÿéå¸¸æœ‰æ½œåŠ›ï¼Œæ¯”å¦‚æˆ‘ä»¬å¸Œæœ›åœ¨è°ƒè¯•æ—¶è·Ÿè¸ªä»»æ„ç³»ç»Ÿè°ƒç”¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡ç±»ä¼¼æ–¹æ³•æ¥å®ç°ï¼Œåé¢æ‰©å±•é˜…è¯»éƒ¨åˆ†ï¼Œæˆ‘ä»¬ä¹Ÿä¼šå•ç‹¬ä¸€èŠ‚å¯¹æ­¤è¿›è¡Œè¿›ä¸€æ­¥çš„ä»‹ç»ã€‚

### è®¾è®¡å®ç°

è¿™éƒ¨åˆ†å®ç°ä»£ç ï¼Œè¯¦è§ [hitzhangjie/golang-debugger-lessons](https://github.com/hitzhangjie/golang-debugger-lessons) / 20_trace_new_threadsã€‚

é¦–å…ˆä¸ºäº†åé¢æµ‹è¯•æ–¹ä¾¿ï¼Œæˆ‘ä»¬å…ˆç”¨Cè¯­è¨€æ¥å®ç°ä¸€ä¸ªå¤šçº¿ç¨‹ç¨‹åºï¼Œç¨‹åºé€»è¾‘å¾ˆç®€å•ï¼Œå°±æ˜¯æ¯éš”ä¸€æ®µæ—¶é—´å°±åˆ›å»ºä¸ªæ–°çº¿ç¨‹ï¼Œçº¿ç¨‹å‡½æ•°å°±æ˜¯æ‰“å°å½“å‰çº¿ç¨‹çš„pidï¼Œä»¥åŠçº¿ç¨‹lwpçš„pidã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <pthread.h>

pid_t gettid(void);

void *threadfunc(void *arg) {
    printf("process: %d, thread: %u\n", getpid(), syscall(SYS_gettid));
    sleep(1);
}

int main() {
    printf("process: %d, thread: %u\n", getpid(), syscall(SYS_gettid));

    pthread_t tid;
    for (int i = 0; i < 100; i++)
    {
        if (i % 10 == 0) {
            int ret = pthread_create(&tid, NULL, threadfunc, NULL);
            if (ret != 0) {
                printf("pthread_create error: %d\n", ret);
                exit(-1);
            }
        }
        sleep(1);
    }
    sleep(15);
}

```

è¿™ä¸ªç¨‹åºå¯ä»¥è¿™æ ·ç¼–è¯‘ `gcc -o fork fork.c -lpthread`ï¼Œç„¶åè¿è¡Œ `./fork` è¿›è¡Œæµ‹è¯•ï¼Œå¯ä»¥çœ‹çœ‹æ²¡æœ‰è¢«è°ƒè¯•è·Ÿè¸ªçš„æ—¶å€™æ˜¯ä¸ªä»€ä¹ˆè¿è¡Œæ•ˆæœã€‚
ç„¶åæˆ‘ä»¬å†æ¥çœ‹è°ƒè¯•å™¨éƒ¨åˆ†çš„ä»£ç é€»è¾‘ï¼Œè¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†æ¼”ç¤ºtracerï¼ˆdebuggerï¼‰å¦‚ä½•å¯¹å¤šçº¿ç¨‹ç¨‹åºä¸­æ–°åˆ›å»ºçš„çº¿ç¨‹è¿›è¡Œæ„ŸçŸ¥ï¼Œå¹¶èƒ½è‡ªåŠ¨è¿½è¸ªï¼Œå¿…è¦æ—¶è¿˜å¯ä»¥å®ç°ç±»ä¼¼ gdb `set follow-fork-mode=child/parent/ask` çš„è°ƒè¯•æ•ˆæœå‘¢ã€‚

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"syscall"
	"time"
)

var usage = `Usage:
	go run main.go <pid>

	args:
	- pid: specify the pid of process to attach
`

func main() {
	runtime.LockOSThread()

	if len(os.Args) != 2 {
		fmt.Println(usage)
		os.Exit(1)
	}

	// pid
	pid, err := strconv.Atoi(os.Args[1])
	if err != nil {
		panic(err)
	}

	if !checkPid(int(pid)) {
		fmt.Fprintf(os.Stderr, "process %d not existed\n\n", pid)
		os.Exit(1)
	}

	// step1: supposing running dlv attach here
	fmt.Fprintf(os.Stdout, "===step1===: supposing running `dlv attach pid` here\n")

	// attach
	err = syscall.PtraceAttach(int(pid))
	if err != nil {
		fmt.Fprintf(os.Stderr, "process %d attach error: %v\n\n", pid, err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "process %d attach succ\n\n", pid)

	// check target process stopped or not
	var status syscall.WaitStatus
	var rusage syscall.Rusage
	_, err = syscall.Wait4(int(pid), &status, 0, &rusage)
	if err != nil {
		fmt.Fprintf(os.Stderr, "process %d wait error: %v\n\n", pid, err)
		os.Exit(1)
	}
	if !status.Stopped() {
		fmt.Fprintf(os.Stderr, "process %d not stopped\n\n", pid)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "process %d stopped\n\n", pid)

	regs := syscall.PtraceRegs{}
	if err := syscall.PtraceGetRegs(int(pid), &regs); err != nil {
		fmt.Fprintf(os.Stderr, "get regs fail: %v\n", err)
		os.Exit(1)
	}
	fmt.Fprintf(os.Stdout, "tracee stopped at %0x\n", regs.PC())

	// step2: setup to trace all new threads creation events
	time.Sleep(time.Second * 2)

	opts := syscall.PTRACE_O_TRACEFORK | syscall.PTRACE_O_TRACEVFORK | syscall.PTRACE_O_TRACECLONE
	if err := syscall.PtraceSetOptions(int(pid), opts); err != nil {
		fmt.Fprintf(os.Stderr, "set options fail: %v\n", err)
		os.Exit(1)
	}

	for {
		// æ”¾è¡Œä¸»çº¿ç¨‹ï¼Œå› ä¸ºæ¯æ¬¡ä¸»çº¿ç¨‹éƒ½ä¼šå› ä¸ºå‘½ä¸­cloneå°±åœä¸‹æ¥
		if err := syscall.PtraceCont(int(pid), 0); err != nil {
			fmt.Fprintf(os.Stderr, "cont fail: %v\n", err)
			os.Exit(1)
		}

		// æ£€æŸ¥ä¸»çº¿ç¨‹çŠ¶æ€ï¼Œæ£€æŸ¥å¦‚æœstatusæ˜¯cloneäº‹ä»¶ï¼Œåˆ™ç»§ç»­è·å–cloneå‡ºçš„çº¿ç¨‹çš„lwp pid
		var status syscall.WaitStatus
		rusage := syscall.Rusage{}
		_, err := syscall.Wait4(pid, &status, syscall.WSTOPPED|syscall.WCLONE, &rusage)
		if err != nil {
			fmt.Fprintf(os.Stderr, "wait4 fail: %v\n", err)
			break
		}
		// æ£€æŸ¥ä¸‹çŠ¶æ€ä¿¡æ¯æ˜¯å¦æ˜¯cloneäº‹ä»¶ (see `man 2 ptrace` å…³äºé€‰é¡¹PTRACE_O_TRACECLONEçš„è¯´æ˜éƒ¨åˆ†)
		isclone := status>>8 == (syscall.WaitStatus(syscall.SIGTRAP) | syscall.WaitStatus(syscall.PTRACE_EVENT_CLONE<<8))
		fmt.Fprintf(os.Stdout, "tracee stopped, tracee pid:%d, status: %s, trapcause is clone: %v\n",
			pid,
			status.StopSignal().String(),
			isclone)

		// è·å–å­çº¿ç¨‹å¯¹åº”çš„lwpçš„pid
		msg, err := syscall.PtraceGetEventMsg(int(pid))
		if err != nil {
			fmt.Fprintf(os.Stderr, "get event msg fail: %v\n", err)
			break
		}
		fmt.Fprintf(os.Stdout, "eventmsg: new thread lwp pid: %d\n", msg)

		// æ”¾è¡Œå­çº¿ç¨‹ç»§ç»­æ‰§è¡Œ
		_ = syscall.PtraceDetach(int(msg))

		time.Sleep(time.Second * 2)
	}

}

// checkPid check whether pid is valid process's id
//
// On Unix systems, os.FindProcess always succeeds and returns a Process for
// the given pid, regardless of whether the process exists.
func checkPid(pid int) bool {
	out, err := exec.Command("kill", "-s", "0", strconv.Itoa(pid)).CombinedOutput()
	if err != nil {
		panic(err)
	}

	// output error message, means pid is invalid
	if string(out) != "" {
		return false
	}

	return true
}

```

### ä»£ç æµ‹è¯•

1ã€å…ˆçœ‹çœ‹testdata/fork.cï¼Œè¿™ä¸ªç¨‹åºæ¯éš”ä¸€æ®µæ—¶é—´å°±åˆ›å»ºä¸€ä¸ªpthreadçº¿ç¨‹å‡ºæ¥

ä¸»çº¿ç¨‹ã€å…¶ä»–çº¿ç¨‹åˆ›å»ºå‡ºæ¥åéƒ½ä¼šæ‰“å°è¯¥çº¿ç¨‹å¯¹åº”çš„pidã€tidï¼ˆè¿™é‡Œçš„tidå°±æ˜¯å¯¹åº”çš„lwpçš„pidï¼‰

```
zhangjieğŸ¦€ testdata(master) $ ./fork 
process: 35573, thread: 35573
process: 35573, thread: 35574
process: 35573, thread: 35716
process: 35573, thread: 35853
process: 35573, thread: 35944
process: 35573, thread: 36086
process: 35573, thread: 36192
process: 35573, thread: 36295
process: 35573, thread: 36398
...
```

2ã€æˆ‘ä»¬åŒæ—¶è§‚å¯Ÿ ./20_trace_new_threads `<ä¸Šè¿°forkç¨‹åºè¿›ç¨‹pid> çš„æ‰§è¡Œæƒ…å†µ`

```
zhangjieğŸ¦€ 20_trace_new_threads(master) $ ./20_trace_new_threads 35573
===step1===: supposing running `dlv attach pid` here
process 35573 attach succ

process 35573 stopped

tracee stopped at 7f318346f098
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 35716
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 35853
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 35944
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 35944
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 35944
tracee stopped, tracee pid:35573, status: trace/breakpoint trap1, trapcause is clone: true
eventmsg: new thread lwp pid: 36086
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 36192
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 36295
tracee stopped, tracee pid:35573, status: trace/breakpoint trap, trapcause is clone: true
eventmsg: new thread lwp pid: 36398
..
```

3ã€20_trace_new_threads æ¯éš”ä¸€æ®µæ—¶é—´éƒ½ä¼šæ‰“å°ä¸€ä¸ªevent msg: `<new thread LWP pid>`

ç»“è®ºå°±æ˜¯ï¼Œæˆ‘ä»¬é€šè¿‡æ˜¾ç¤ºè®¾ç½®PtraceSetOptions(pid, syscall.PTRACE_O_TRACECLONE)åï¼Œæ¢å¤traceeæ‰§è¡Œï¼Œè¿™æ ·traceeæ‰§è¡Œèµ·æ¥åï¼Œå½“æ‰§è¡Œåˆ°cloneç³»ç»Ÿè°ƒç”¨æ—¶ï¼Œå°±ä¼šè§¦å‘ä¸€ä¸ªTRAPï¼Œå†…æ ¸ä¼šç»™tracerå‘é€ä¸€ä¸ªSIGTRAPæ¥é€šçŸ¥traceeè¿è¡ŒçŠ¶æ€å˜åŒ–ã€‚ç„¶åtracerå°±å¯ä»¥æ£€æŸ¥å¯¹åº”çš„statusæ•°æ®ï¼Œæ¥åˆ¤æ–­æ˜¯å¦æ˜¯å¯¹åº”çš„cloneäº‹ä»¶ã€‚

å¦‚æœæ˜¯cloneäº‹ä»¶ï¼Œæˆ‘ä»¬å¯ä»¥ç»§ç»­é€šè¿‡syscall.PtraceGetEventMsg(...)æ¥è·å–æ–°cloneå‡ºæ¥çš„çº¿ç¨‹çš„LWPçš„pidã€‚

æ£€æŸ¥æ˜¯ä¸æ˜¯cloneäº‹ä»¶å‘¢ï¼Œå‚è€ƒ man 2 ptraceæ‰‹å†Œå¯¹é€‰é¡¹PTRACE_O_TRACECLONEçš„ä»‹ç»éƒ¨åˆ†ï¼Œæœ‰è§£é‡ŠcloneçŠ¶å†µä¸‹çš„statuså€¼å¦‚ä½•ç¼–ç ã€‚

4ã€å¦å¤–è®¾ç½®äº†é€‰é¡¹PTRACE_O_TRACECLONEä¹‹åï¼Œæ–°çº¿ç¨‹ä¼šè‡ªåŠ¨è¢«traceï¼Œæ‰€ä»¥æ–°çº¿ç¨‹ä¹Ÿä¼šè¢«æš‚åœæ‰§è¡Œï¼Œæ­¤æ—¶å¦‚æœå¸Œæœ›æ–°çº¿ç¨‹æ¢å¤æ‰§è¡Œï¼Œæˆ‘ä»¬éœ€è¦æ˜¾ç¤ºå°†å…¶syscall.PtraceDetachæˆ–è€…æ‰§è¡Œsyscall.PtraceContinueæ“ä½œæ¥è®©æ–°çº¿ç¨‹æ¢å¤æ‰§è¡Œã€‚

### å¼•ç”³ä¸€ä¸‹

è‡³æ­¤ï¼Œæµ‹è¯•æ–¹æ³•ä»‹ç»å®Œäº†ï¼Œæˆ‘ä»¬å¯ä»¥å¼•ç”³ä¸‹ï¼Œåœ¨æˆ‘ä»¬è¿™ä¸ªæµ‹è¯•çš„åŸºç¡€ä¸Šæˆ‘ä»¬å¯ä»¥æç¤ºç”¨æˆ·ï¼Œä½ æƒ³è·Ÿè¸ªå½“å‰çº¿ç¨‹å‘¢ï¼Œè¿˜æ˜¯æƒ³è·Ÿè¸ªæ–°çº¿ç¨‹å‘¢ï¼Ÿç±»ä¼¼åœ°è¿™ä¸ªåœ¨gdbè°ƒè¯•å¤šè¿›ç¨‹ã€å¤šçº¿ç¨‹ç¨‹åºæ—¶æ—¶éå¸¸æœ‰ç”¨çš„ï¼Œè”æƒ³ä¸‹gdbä¸­çš„ `set follow-fork-mode` ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹© parentã€childã€ask ä¸­çš„ä¸€ç§ï¼Œå¹¶ä¸”å…è®¸åœ¨è°ƒè¯•æœŸé—´åœ¨ä¸Šè¿°é€‰é¡¹ä¹‹é—´è¿›è¡Œåˆ‡æ¢ï¼Œå¦‚æœæˆ‘ä»¬æå‰è§„åˆ’å¥½äº†ï¼Œforkåè¦è·Ÿè¸ªå½“å‰çº¿ç¨‹è¿˜æ˜¯å­çº¿ç¨‹ï¼ˆorè¿›ç¨‹ï¼‰ï¼Œè¿™ä¸ªåŠŸèƒ½ç‰¹æ€§å°±éå¸¸çš„æœ‰ç”¨ã€‚

dlvé‡Œé¢æä¾›äº†ä¸€ç§ä¸åŒçš„åšæ³•ï¼Œå®ƒæ˜¯é€šè¿‡threadsæ¥åˆ‡æ¢è¢«è°ƒè¯•çš„çº¿ç¨‹çš„ï¼Œå®é™…ä¸Šgoä¹Ÿä¸ä¼šæš´æ¼çº¿ç¨‹å˜æˆapiç»™å¼€å‘è€…ï¼Œå¤§å®¶å¤§å¤šæ•°æ—¶å€™åº”è¯¥ä¹Ÿç”¨ä¸åˆ°å»æ˜¾ç¤ºè·Ÿè¸ªcloneæ–°å»ºçº¿ç¨‹åæ–°çº¿ç¨‹çš„æ‰§è¡Œæƒ…å†µï¼Œæ‰€ä»¥åº”è¯¥æå°‘åƒgdb set follow-fork-modeè°ƒè¯•æ¨¡å¼ä¸€æ ·å»ä½¿ç”¨ã€‚æˆ‘ä»¬è¿™é‡Œåªæ˜¯å¼•ç”³ä¸€ä¸‹ã€‚
