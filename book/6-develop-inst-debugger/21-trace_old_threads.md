## æ‰©å±•é˜…è¯»ï¼šå¦‚ä½•è·Ÿè¸ªå·²ç»åˆ›å»ºçš„çº¿ç¨‹

### å®ç°ç›®æ ‡ï¼šè·Ÿè¸ªå·²ç»åˆ›å»ºçš„çº¿ç¨‹

è¢«è°ƒè¯•è¿›ç¨‹æ˜¯å¤šçº¿ç¨‹ç¨‹åºï¼Œåœ¨æˆ‘ä»¬å‡†å¤‡å¼€å§‹è°ƒè¯•æ—¶ï¼Œè¿™äº›çº¿ç¨‹å°±å·²ç»è¢«åˆ›å»ºå¹¶åœ¨è¿è¡Œäº†ã€‚æˆ‘ä»¬æ‰§è¡Œè°ƒè¯•å™¨ attach æ“ä½œæ—¶ï¼Œä¹Ÿä¸ä¼šæšä¸¾æ‰€æœ‰çº¿ç¨‹ç„¶åæ‰‹åŠ¨å» attach æ¯ä¸ªçº¿ç¨‹ï¼Œä¸ºäº†æ–¹ä¾¿æˆ‘ä»¬åªä¼šå»æ‰‹åŠ¨ attach è¿›ç¨‹ï¼Œç„¶åå¸Œæœ›ç¨‹åºä¾§èƒ½å¸®æˆ‘ä»¬å¤„ç†è¿›ç¨‹å†…éä¸»çº¿ç¨‹ä»¥å¤–å…¶ä»–çº¿ç¨‹çš„ attach æ“ä½œã€‚

ä»¥dlvä¸ºä¾‹ï¼Œä¸ä¸€å®š `dlv attach <pid>` ä¹‹åå°±ç«‹å³æšä¸¾æ‰€æœ‰çº¿ç¨‹ç„¶åé€ä¸ªattachï¼Œä½†æ˜¯è¦å…·å¤‡è¿™ä¸ªèƒ½åŠ›ï¼Œæ¯”å¦‚å½“è°ƒè¯•äººå‘˜å¸Œæœ›è·Ÿè¸ªæŸä¸ªç‰¹å®šçº¿ç¨‹æ—¶ï¼Œæˆ‘ä»¬èƒ½å¤Ÿæ–¹ä¾¿åœ°æ‰§è¡Œè¿™ä¸ªæ“ä½œï¼Œæ¯”å¦‚ `dlv>threads` æŸ¥çœ‹çº¿ç¨‹åˆ—è¡¨åï¼Œå¯ä»¥ç»§ç»­ `dlv> thread <n>` æ¥æŒ‡åé“å§“åœ°è·Ÿè¸ªç‰¹å®šçº¿ç¨‹ã€‚

Goç¨‹åºå¤©ç„¶æ˜¯å¤šçº¿ç¨‹ç¨‹åºï¼Œè€Œä¸”æ˜¯æä¾›ç»™å¼€å‘è€…çš„æ˜¯goroutineå¹¶å‘æ¥å£ï¼Œå¹¶ä¸æ˜¯threadå¹¶å‘ç›¸å…³çš„æ¥å£ï¼Œæ‰€ä»¥å³ä½¿dlvæœ‰è¿™ä¸ªèƒ½åŠ›ï¼Œä¹Ÿä¸ä¸€å®šç»å¸¸ä¼šç”¨åˆ°threadç›¸å…³çš„è°ƒè¯•å‘½ä»¤ï¼Œå› ä¸ºgmpè°ƒåº¦æ¨¡å‹çš„å­˜åœ¨ï¼Œä½ ä¹Ÿä¸ç¡®å®šåŒä¸€ä¸ªthreadä¸Šæ‰§è¡Œçš„åˆ°åº•æ˜¯å•¥ï¼Œå®ƒæ‰§è¡Œçš„goroutineä¼šåˆ‡æ¢æ¥åˆ‡æ¢å»ã€‚åå€’æ˜¯ `dlv> goroutines` å’Œ `dlv> goroutine <n>` ä½¿ç”¨é¢‘ç‡æ›´é«˜ã€‚

anywayï¼Œæˆ‘ä»¬å¿…é¡»è¯´æ˜çš„æ˜¯ï¼Œæˆ‘ä»¬è¿˜æ˜¯å¸Œæœ›èƒ½äº†è§£å¤šçº¿ç¨‹è°ƒè¯•çš„ç›¸å…³åº•å±‚ç»†èŠ‚ï¼Œä½ å¯èƒ½å°†æ¥ä¼šä¸ºå…¶ä»–è¯­è¨€å¼€å‘è°ƒè¯•å™¨ï¼Œå¯¹å§ï¼Ÿå¹¶ä¸ä¸€å®šæ˜¯goè¯­è¨€ï¼Œå¦‚æœé‚£ç§è¯­è¨€æ˜¯é¢å‘threadçš„å¹¶å‘ï¼Œé‚£è¿™äº›çŸ¥è¯†çš„å®ç”¨æ€§ä»·å€¼è¿˜æ˜¯å­˜åœ¨çš„ã€‚

### åŸºç¡€çŸ¥è¯†

æˆ‘ä»¬å¦‚ä½•è·å–è¿›ç¨‹å†…æ‰€æœ‰çº¿ç¨‹å‘¢ï¼Ÿæˆ‘ä»¬æ‰§è¡Œ `top -H -p <pid>` å¯ä»¥åˆ—å‡ºæŒ‡å®šè¿›ç¨‹å†…æ‰€æœ‰çº¿ç¨‹ä¿¡æ¯ï¼Œå¯ä»¥è§£ææ‹¿åˆ°æ‰€æœ‰çº¿ç¨‹idã€‚ä½†æ˜¯Linux /proc è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæä¾›äº†æ›´æ–¹ä¾¿çš„æ–¹å¼ã€‚å…¶å®åªè¦éå† `/proc/<pid>/task` ä¸‹çš„æ‰€æœ‰ç›®å½•åå³å¯ã€‚Linuxå†…æ ¸ä¼šåœ¨ä¸Šè¿°ç›®å½•ä¸‹ç»´æŠ¤çº¿ç¨‹å¯¹åº”çš„ä»»åŠ¡ä¿¡æ¯ï¼Œæ¯ä¸ªç›®å½•çš„åå­—æ˜¯ä¸€ä¸ªçº¿ç¨‹LWPçš„pidï¼Œæ¯ä¸ªç›®å½•å†…å®¹åŒ…å«äº†è¿™ä¸ªä»»åŠ¡çš„ä¸€äº›ä¿¡æ¯ã€‚

ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬çœ‹ä¸‹pid=1çš„è¿›ç¨‹çš„ä¸€äº›ä¿¡æ¯ï¼š

```bash
rootğŸ¦€ ~ $ ls /proc/1/task/1/
arch_status  clear_refs  environ  io         mounts     oom_score_adj  sched         stack    uid_map
attr         cmdline     exe      limits     net        pagemap        schedstat     stat     wchan
auxv         comm        fd       maps       ns         personality    setgroups     statm
cgroup       cpuset      fdinfo   mem        oom_adj    projid_map     smaps         status
children     cwd         gid_map  mountinfo  oom_score  root           smaps_rollup  syscall
```

/proc è™šæ‹Ÿæ–‡ä»¶ç³»ç»Ÿæ˜¯å†…æ ¸æä¾›çš„ä¸€ä¸ªä¸å†…æ ¸äº¤äº’çš„æ¥å£ï¼Œå¯ä»¥è¯»å¯ä»¥å†™ï¼Œè¿™å¹¶ä¸æ˜¯ä»€ä¹ˆé‡è·¯å­ï¼Œè€Œæ˜¯éå¸¸åœ°é“çš„æ–¹æ³•ï¼Œç›¸æ¯”å¦‚topã€vmstatã€cgroupç­‰ç­‰å¸¸è§å·¥å…·ä¹Ÿæ˜¯é€šè¿‡è®¿é—® /proc æ¥è¾¾æˆç›¸å…³åŠŸèƒ½ã€‚
OKï¼Œå¯¹æˆ‘ä»¬è¿™ä¸ªè°ƒè¯•å™¨è€Œè¨€ï¼Œç›®å‰æˆ‘ä»¬åªéœ€è¦ç›´åˆ°ï¼š

- è¦æšä¸¾è¿›ç¨‹çš„æ‰€æœ‰çº¿ç¨‹ï¼Œæˆ‘ä»¬å°±éå† `/proc/<pid>/task` ä¸‹çš„ç›®å½•ï¼›
- è¦è¯»å–å…¶å®Œæ•´çš„æŒ‡ä»¤æ•°æ®æ—¶ï¼Œæˆ‘ä»¬å°±è¯»å–ç›®å½•ä¸‹çš„ exe æ–‡ä»¶ï¼›
- è¦è¯»å–å…¶å¯åŠ¨å‚æ•°æ•°æ®ï¼Œæ–¹ä¾¿é‡å¯è¢«è°ƒè¯•è¿›ç¨‹ã€é‡å¯è°ƒè¯•æ—¶ï¼Œæˆ‘ä»¬å°±è¯»å–ç›®å½•ä¸‹çš„ cmdline æ–‡ä»¶ï¼›

OKï¼Œå…¶ä»–çš„å½“å‰æˆ‘ä»¬å¯ä»¥å…ˆä¸å…³æ³¨ã€‚

### è®¾è®¡å®ç°

è¿™éƒ¨åˆ†å®ç°ä»£ç ï¼Œè¯¦è§ [hitzhangjie/golang-debugger-lessons](https://github.com/hitzhangjie/golang-debugger-lessons) / 21_trace_old_threadsã€‚

é¦–å…ˆä¸ºäº†æµ‹è¯•æ–¹ä¾¿ï¼Œæˆ‘ä»¬å…ˆå‡†å¤‡ä¸€ä¸ªtestdata/fork_noquit.cçš„æµ‹è¯•ç¨‹åºï¼Œè·Ÿå‰ä¸€å°èŠ‚çš„testdata/fork.cç±»ä¼¼ï¼Œå®ƒä¼šåˆ›å»ºçº¿ç¨‹å¹¶ä¸”æ‰“å°pidã€tidä¿¡æ¯ï¼Œä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œçš„çº¿ç¨‹æ°¸è¿œä¸ä¼šé€€å‡ºï¼Œä¸»è¦ç›®çš„æ˜¯ç»™æˆ‘ä»¬è°ƒè¯•ç•™ä¸‹æ›´å……è¶³çš„æ—¶é—´ï¼Œé¿å…å› ä¸ºçº¿ç¨‹é€€å‡ºå¯¼è‡´åç»­è·Ÿè¸ªçº¿ç¨‹å¤±è´¥ã€‚

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <pthread.h>

pid_t gettid(void);

void *threadfunc(void *arg) {
    printf("process: %d, thread: %u\n", getpid(), syscall(SYS_gettid));
    while (1) {
        sleep(1);
    }
}

int main() {
    printf("process: %d, thread: %u\n", getpid(), syscall(SYS_gettid));

    pthread_t tid;
    for (int i = 0; i < 100; i++)
    {
        if (i % 10 == 0) {
            int ret = pthread_create(&tid, NULL, threadfunc, NULL);
            if (ret != 0) {
                printf("pthread_create error: %d\n", ret);
                exit(-1);
            }
        }
        sleep(1);
    }
    while(1) {
        sleep(1);
    }
}

```

è¿™ä¸ªç¨‹åºå¯ä»¥è¿™æ ·ç¼–è¯‘ `gcc -o fork_noquit fork_noquit.c -lpthread`ï¼Œç„¶åè¿è¡Œ `./fork_noquit` è§‚å¯Ÿå…¶è¾“å‡ºã€‚

ç„¶åæˆ‘ä»¬å†æ¥çœ‹çœ‹è°ƒè¯•å™¨éƒ¨åˆ†çš„ä»£ç é€»è¾‘ï¼Œè¿™é‡Œä¸»è¦æ˜¯ä¸ºäº†æ¼”ç¤ºå¦‚ä½•å¾…è°ƒè¯•è¿›ç¨‹ä¸­å·²ç»åˆ›å»ºçš„çº¿ç¨‹ï¼Œä»¥åŠå¦‚ä½•å»è·Ÿè¸ªå®ƒä»¬ï¼Œå¦‚ä½•ä»è·Ÿè¸ªè¿™ä¸ªçº¿ç¨‹åˆ‡æ¢ä¸ºè·Ÿè¸ªå¦ä¸€ä¸ªçº¿ç¨‹ã€‚
ç¨‹åºæ ¸å¿ƒé€»è¾‘å¦‚ä¸‹ï¼š

- æˆ‘ä»¬æ‰§è¡Œ `./21_trace_old_threads $(pidof fork_noquit)`ï¼Œæ­¤æ—¶ä¼šæ£€æŸ¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨
- ç„¶åå›æšä¸¾è¿›ç¨‹ä¸­å·²åˆ›å»ºçš„çº¿ç¨‹ï¼Œæ–¹å¼å°±æ˜¯é€šè¿‡è¯»å– /proc ä¸‹çš„ä¿¡æ¯ï¼Œç„¶åè¾“å‡ºæ‰€æœ‰çº¿ç¨‹id
- ç„¶åæç¤ºç”¨æˆ·è¾“å…¥ä¸€ä¸ªå¸Œæœ›è·Ÿè¸ªçš„ç›®æ ‡çº¿ç¨‹idï¼Œè¾“å…¥åå¼€å§‹è·Ÿè¸ªè¿™ä¸ªçº¿ç¨‹ï¼Œ
- å½“è·Ÿè¸ªä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œå¦‚æœæ­¤å‰æœ‰æ­£åœ¨è·Ÿè¸ªçš„çº¿ç¨‹ï¼Œéœ€è¦å…ˆåœæ­¢è·Ÿè¸ªæ—§çº¿ç¨‹ï¼Œç„¶åå†ç»§ç»­è·Ÿè¸ªæ–°çº¿ç¨‹

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"strconv"
	"syscall"
	"time"
)

var usage = `Usage:
	go run main.go <pid>

	args:
	- pid: specify the pid of process to attach
`

func main() {
	runtime.LockOSThread()

	if len(os.Args) != 2 {
		fmt.Println(usage)
		os.Exit(1)
	}

	fmt.Fprintf(os.Stdout, "===step1===: check target process existed or not\n")
	// pid
	pid, err := strconv.Atoi(os.Args[1])
	if err != nil {
		panic(err)
	}

	if !checkPid(int(pid)) {
		fmt.Fprintf(os.Stderr, "process %d not existed\n\n", pid)
		os.Exit(1)
	}

	// enumerate all threads
	fmt.Fprintf(os.Stdout, "===step2===: enumerate created threads by reading /proc\n")

	// read dir entries of /proc/<pid>/task/
	threads, err := readThreadIDs(pid)
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(os.Stdout, "threads: %v\n", threads)

	// prompt user which thread to attach
	var last int64

	// attach thread <n>, or switch thread to another one thread <m>
	for {
		fmt.Fprintf(os.Stdout, "===step3===: supposing running `dlv> thread <n>` here\n")
		var target int64
		n, err := fmt.Fscanf(os.Stdin, "%d\n", &target)
		if n == 0 || err != nil || target <= 0 {
			panic("invalid input, thread id should > 0")
		}

		if last > 0 {
			if err := syscall.PtraceDetach(int(last)); err != nil {
				fmt.Fprintf(os.Stderr, "switch from thread %d to thread %d error: %v\n", last, target, err)
				os.Exit(1)
			}
			fmt.Fprintf(os.Stderr, "switch from thread %d thread %d\n", last, target)
		}

		// attach
		err = syscall.PtraceAttach(int(target))
		if err != nil {
			fmt.Fprintf(os.Stderr, "thread %d attach error: %v\n\n", target, err)
			os.Exit(1)
		}
		fmt.Fprintf(os.Stdout, "process %d attach succ\n\n", target)

		// check target process stopped or not
		var status syscall.WaitStatus
		var rusage syscall.Rusage
		_, err = syscall.Wait4(int(target), &status, 0, &rusage)
		if err != nil {
			fmt.Fprintf(os.Stderr, "process %d wait error: %v\n\n", target, err)
			os.Exit(1)
		}
		if !status.Stopped() {
			fmt.Fprintf(os.Stderr, "process %d not stopped\n\n", target)
			os.Exit(1)
		}
		fmt.Fprintf(os.Stdout, "process %d stopped\n\n", target)

		regs := syscall.PtraceRegs{}
		if err := syscall.PtraceGetRegs(int(target), &regs); err != nil {
			fmt.Fprintf(os.Stderr, "get regs fail: %v\n", err)
			os.Exit(1)
		}
		fmt.Fprintf(os.Stdout, "tracee stopped at %0x\n", regs.PC())

		last = target
		time.Sleep(time.Second)
	}
}

// checkPid check whether pid is valid process's id
//
// On Unix systems, os.FindProcess always succeeds and returns a Process for
// the given pid, regardless of whether the process exists.
func checkPid(pid int) bool {
	out, err := exec.Command("kill", "-s", "0", strconv.Itoa(pid)).CombinedOutput()
	if err != nil {
		panic(err)
	}

	// output error message, means pid is invalid
	if string(out) != "" {
		return false
	}

	return true
}

// reads all thread IDs associated with a given process ID.
func readThreadIDs(pid int) ([]int, error) {
	dir := fmt.Sprintf("/proc/%d/task", pid)
	files, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	var threads []int
	for _, file := range files {
		tid, err := strconv.Atoi(file.Name())
		if err != nil { // Ensure that it's a valid positive integer
			continue
		}
		threads = append(threads, tid)
	}
	return threads, nil
}
```

### ä»£ç æµ‹è¯•

1ã€å…ˆçœ‹çœ‹testdata/fork_noquit.cï¼Œè¿™ä¸ªç¨‹åºæ¯éš”ä¸€æ®µæ—¶é—´å°±åˆ›å»ºä¸€ä¸ªpthreadçº¿ç¨‹å‡ºæ¥

ä¸»çº¿ç¨‹ã€å…¶ä»–çº¿ç¨‹åˆ›å»ºå‡ºæ¥åéƒ½ä¼šæ‰“å°è¯¥çº¿ç¨‹å¯¹åº”çš„pidã€tidï¼ˆè¿™é‡Œçš„tidå°±æ˜¯å¯¹åº”çš„lwpçš„pidï¼‰

> ps: fork_noquit.c å’Œ fork.c çš„åŒºåˆ«å°±æ˜¯æ¯ä¸ªçº¿ç¨‹éƒ½ä¼šä¸åœsleep(1) æ°¸è¿œä¸ä¼šé€€å‡ºï¼Œè¿™ä¹ˆåšçš„ç›®çš„å°±æ˜¯æˆ‘ä»¬è·‘è¿™ä¸ªæµ‹è¯•ç”¨æ—¶æ¯”è¾ƒä¹…ï¼Œè®©çº¿ç¨‹ä¸é€€å‡ºå¯ä»¥é¿å…æˆ‘ä»¬è¾“å…¥çº¿ç¨‹idæ‰§è¡Œattach thread æˆ–è€… switch thread1 to thread2 æ—¶å‡ºç°çº¿ç¨‹å·²é€€å‡ºå¯¼è‡´å¤±è´¥çš„æƒ…å†µã€‚

ä¸‹é¢æ‰§è¡Œè¯¥ç¨‹åºç­‰å¾…è¢«è°ƒè¯•å™¨è°ƒè¯•ï¼š

```bash
zhangjieğŸ¦€ testdata(master) $ ./fork_noquit
process: 12368, thread: 12368
process: 12368, thread: 12369
process: 12368, thread: 12527
process: 12368, thread: 12599
process: 12368, thread: 12661
...
```

2ã€æˆ‘ä»¬åŒæ—¶è§‚å¯Ÿ ./21_trace_old_threads `<ä¸Šè¿°fork_noquitç¨‹åºè¿›ç¨‹pid>` çš„æ‰§è¡Œæƒ…å†µ

```bash
zhangjieğŸ¦€ 21_trace_old_threads(master) $ ./21_trace_old_threads 12368
===step1===: check target process existed or not

===step2===: enumerate created threads by reading /proc
threads: [12368 12369 12527 12599 12661 12725 12798 12864 12934 13004 13075]    <= created thread IDs

===step3===: supposing running `dlv> thread <n>` here
12369
process 12369 attach succ                                                       <= prompt user input and attach thread
process 12369 stopped
tracee stopped at 7f06c29cf098

===step3===: supposing running `dlv> thread <n>` here
12527
switch from thread 12369 thread 12527
process 12527 attach succ                                                       <= prompt user input and switch thread
process 12527 stopped
tracee stopped at 7f06c29cf098

===step3===: supposing running `dlv> thread <n>` here

```

3ã€ä¸Šé¢æˆ‘ä»¬å…ˆåè¾“å…¥äº†ä¸¤ä¸ªçº¿ç¨‹idï¼Œç¬¬ä¸€æ¬¡è¾“å…¥çš„12369ï¼Œç¬¬äºŒæ¬¡è¾“å…¥çš„æ—¶12527ï¼Œæˆ‘ä»¬åˆ†åˆ«çœ‹ä¸‹è¿™ä¸¤æ¬¡è¾“å…¥æ—¶çº¿ç¨‹çŠ¶æ€å˜åŒ–å¦‚ä½•

æœ€å¼€å§‹æ²¡æœ‰è¾“å…¥æ—¶ï¼Œçº¿ç¨‹çŠ¶æ€éƒ½æ˜¯ Sï¼Œè¡¨ç¤ºSleepï¼Œå› ä¸ºçº¿ç¨‹ä¸€ç›´åœ¨åš `while(1) {sleep(1);}` è¿™ä¸ªæ“ä½œï¼Œå¤„äºsleepçŠ¶æ€å¾ˆå¥½ç†è§£ã€‚

```bash
$ top -H -p 12368

top - 00:54:17 up 8 days,  2:10,  2 users,  load average: 0.02, 0.06, 0.08
Threads:   7 total,   0 running,   7 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.1 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  31964.6 total,  26011.4 free,   4052.5 used,   1900.7 buff/cache
MiB Swap:   8192.0 total,   8192.0 free,      0.0 used.  27333.2 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
12368 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12369 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12527 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12599 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12661 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12725 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
12798 zhangjie  20   0   55804    888    800 S   0.0   0.0   0:00.00 fork_noquit
...
```

åœ¨æˆ‘ä»¬è¾“å…¥äº†12369åï¼Œçº¿ç¨‹12369çš„çŠ¶æ€ä» S å˜æˆäº† tï¼Œè¡¨ç¤ºçº¿ç¨‹ç°åœ¨æ­£åœ¨è¢«è°ƒè¯•å™¨è°ƒè¯•ï¼ˆtracedçŠ¶æ€ï¼‰

```bash
12369 zhangjie  20   0   88588    888    800 t   0.0   0.0   0:00.00 fork_noquit
```

åœ¨æˆ‘ä»¬ç»§ç»­è¾“å…¥äº†12527ä¹‹åï¼Œè°ƒè¯•è¡Œä¸ºä»è·Ÿè¸ªçº¿ç¨‹12369å˜ä¸ºè·Ÿè¸ª12527,ï¼Œæˆ‘ä»¬çœ‹åˆ°çº¿ç¨‹12369é‡æ–°ä»tåˆ‡æ¢ä¸ºSï¼Œè€Œ12527ä»Såˆ‡æ¢ä¸ºt

```bash
12369 zhangjie  20   0   88588    888    800 S   0.0   0.0   0:00.00 fork_noquit
12527 zhangjie  20   0   88588    888    800 t   0.0   0.0   0:00.00 fork_noquit
```

OKï¼Œctrl+cæ€æ­» ./21_trace_old_threads è¿›ç¨‹ï¼Œç„¶åæˆ‘ä»¬ç»§ç»­è§‚å¯Ÿçº¿ç¨‹çš„çŠ¶æ€ï¼Œä¼šè‡ªåŠ¨ä»tå˜ä¸ºSï¼Œå› ä¸ºå†…æ ¸ä¼šè´Ÿè´£å–„åï¼Œå³åœ¨traceré€€å‡ºåï¼Œå°†æ‰€æœ‰çš„traceeæ¢å¤æ‰§è¡Œã€‚

### å¼•ç”³ä¸€ä¸‹

å¤§å®¶åœ¨è¿›è¡Œå¤šçº¿ç¨‹è°ƒè¯•æ—¶ï¼Œæœ‰å¯èƒ½ä¼šåªè·Ÿè¸ªä¸€ä¸ªçº¿ç¨‹ï¼Œä¹Ÿå¯èƒ½ä¼šåŒæ—¶è·Ÿè¸ªå¤šä¸ªçº¿ç¨‹ï¼Œæœ€ç»ˆå®ç°å½¢å¼å–å†³äºè°ƒè¯•å™¨çš„äº¤äº’è®¾è®¡ï¼Œæ¯”å¦‚å‘½ä»¤è¡Œå½¢å¼çš„è°ƒè¯•å™¨å› ä¸ºç•Œé¢äº¤äº’çš„åŸå› å¾€å¾€æ›´å€¾å‘äºè·Ÿè¸ªä¸€ä¸ªçº¿ç¨‹ï¼Œä½†æ˜¯æœ‰äº›å›¾å½¢åŒ–ç•Œé¢çš„IDEå¯èƒ½ä¼šå€¾å‘äºæä¾›åŒæ—¶è·Ÿè¸ªå¤šä¸ªçº¿ç¨‹çš„èƒ½åŠ›ï¼ˆä»¥å‰ä½¿ç”¨Eclipseè°ƒè¯•Javaå¤šçº¿ç¨‹ç¨‹åºæ—¶å°±ç»å¸¸è¿™ä¹ˆç©ï¼‰ã€‚æˆ‘ä»¬è¿™é‡Œæ¼”ç¤ºäº†è¿™ä¸ªèƒ½åŠ›è¯¥å¦‚ä½•å®ç°ï¼Œè¯»è€…å¯¹äºå¦‚ä½•å®ç°åŒæ—¶è·Ÿè¸ªå¤šä¸ªçº¿ç¨‹åº”è¯¥ä¹Ÿèƒ½è‡ªå·±å®ç°äº†ã€‚
