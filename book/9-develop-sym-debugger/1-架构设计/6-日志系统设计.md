## tinydbg 日志系统设计

### 多层次的调试器与日志挑战

现代调试器是一个复杂的系统，通常包含多个层次和组件，如核心调试引擎、RPC通信层、函数调用处理、堆栈跟踪等。在这种复杂的系统中，如果没有一个精心设计的日志系统，将会导致以下问题：

1. **问题定位困难**：当调试器出现问题时，难以快速定位问题发生在哪个层次或组件中
2. **日志混乱**：不同层次的日志混杂在一起，缺乏清晰的分类和标识
3. **信息不完整**：关键上下文信息缺失，难以理解日志产生的具体场景
4. **性能影响**：不当的日志记录可能会影响调试器的性能

因此，一个设计良好的日志系统对于调试器的开发和维护至关重要。

### tinydbg 的日志系统设计

tinydbg 的日志系统基于 Go 1.21 的 `slog` 包实现，并进行了定制化设计。其核心设计特点如下：

#### 层次化的日志分类

tinydbg 将日志分为多个层次，每个层次对应调试器的不同组件：

- `debugger`：核心调试器层的日志
- `debuglineerr`：DWARF 行号信息处理相关的错误日志
- `rpc`：RPC 通信层的日志
- `fncall`：函数调用相关的日志
- `stack`：堆栈跟踪相关的日志

这种分类使得日志具有清晰的层次结构，便于问题定位和分析。

#### 灵活的日志配置

日志系统提供了灵活的配置选项：

1. **日志开关控制**：
   - 可以全局开启/关闭日志
   - 可以单独控制每个层次的日志开关

2. **日志输出目标**：
   - 支持输出到文件描述符
   - 支持输出到文件路径
   - 默认输出到标准错误

3. **日志级别**：
   - 支持 Debug、Info、Warn、Error 四个级别
   - 每个层次可以独立设置日志级别

#### 结构化的日志格式

日志系统采用了结构化的日志格式，每条日志包含：

1. **时间戳**：使用 RFC3339 格式
2. **日志级别**：小写形式（debug/info/warn/error）
3. **上下文属性**：以 key=value 形式展示
4. **日志消息**：具体的日志内容

示例日志格式：
```
2024-03-21T10:30:45Z debug layer=debugger,kind=fncall message content
```

#### 自定义 Handler 实现

tinydbg 实现了自定义的 `textHandler`，它：

1. 重写了 `slog.Handler` 接口
2. 优化了日志格式化过程
3. 支持属性预格式化，提高性能
4. 实现了灵活的日志级别控制

#### 便捷的日志接口

提供了两组便捷的日志接口：

1. **格式化接口**：
   - `Debugf/Infof/Warnf/Errorf`：支持格式化字符串

2. **直接接口**：
   - `Debug/Info/Warn/Error`：直接输出参数

每个层次都提供了对应的 Logger 获取函数，如：
- `LogDebuggerLogger()`
- `LogDebugLineLogger()`
- `RPCLogger()`
- `FnCallLogger()`
- `StackLogger()`

### 总结

tinydbg 的日志系统设计充分考虑了调试器的特点和需求：

1. **层次化设计**：通过清晰的层次划分，使日志具有更好的可读性和可维护性
2. **灵活性**：提供了丰富的配置选项，满足不同场景的需求
3. **性能优化**：通过预格式化等机制，确保日志记录不会影响调试器性能
4. **易用性**：提供了简单直观的接口，方便开发人员使用

这种设计不仅提高了调试器的可维护性，也为问题诊断和性能分析提供了有力支持。在实际使用中，开发人员可以快速定位问题，理解系统行为，提高开发效率。 
